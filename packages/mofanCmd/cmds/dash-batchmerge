#!/usr/bin/env node
const program = require("commander");
const shelljs = require("../utils/shelljsUtil");
const { spawn } = require('child_process');
const { askFortargetBranchs } = require("../utils/config");

// const jenkinsUrl = (app, env) =>
//   `http://192.168.0.163:8080/job/tenant-fe/job/${env}/job/${app}/build?token=jenkins-szhtxx-token `;

// åˆ›å»ºä¸€ä¸ªå­è¿›ç¨‹æ¥æ‰§è¡Œåˆå¹¶æ“ä½œ && git merge ${source_branch} 
function executeBranch(branch, source_branch) {
  return new Promise((resolve, reject) => {
    console.log("ğŸš€ ~ file: dash-batchmerge:15 ~ returnnewPromise ~ process.cwd():", process.cwd())
    const child = spawn('git', [`status`, `fetch`, "checkout " + branch], {
      cwd: process.cwd(),
    });

    // è¾“å‡ºå­è¿›ç¨‹çš„è¾“å‡º
    child.stdout.on('data', (data) => {
      console.log(`å­è¿›ç¨‹è¾“å‡º: ${data}`);
    });

    // å­è¿›ç¨‹é”™è¯¯ä¿¡æ¯
    child.stderr.on('data', (data) => {
      console.error(`å­è¿›ç¨‹é”™è¯¯: ${data}`);
    });

    // è·å–å‘½ä»¤è¾“å‡º
    child.on('close', (code) => {
      console.log('stdout: ' + child.stdout.data);
      console.log('stderr: ' + child.stderr.data);
    });

    // è¾“å‡ºå­è¿›ç¨‹çš„å½“å‰å·¥ä½œç›®å½•
    console.log(`å­è¿›ç¨‹çš„å½“å‰å·¥ä½œç›®å½•: ${childProcess.cwd()}`);
  });
}

program
  .option("-s, --source <source>", "source branch")
  .option("-t, --targets [targets...]", "target branch")
  .action(function ({ source, targets }, args) {
    const run = (branchs, sourceBranch) => {
      Promise.all(
        branchs.map(branch => executeBranch(branch, sourceBranch))
      )
        .then(results => {
          console.log(`Successfully merged $source_branch into ${branchs}`);
          console.log(`Results: ${results}`);
        })
        .catch(error => {
          console.error(`Failed to merge ${sourceBranch} into ${branchs}\nError: ${error}`);
        });
    };

    const dealwithBranchs = (targetBranchs, sourceBranch) => {
      if (targetBranchs && targetBranchs.length) {
        run(targetBranchs, sourceBranch);
      } else {
        askFortargetBranchs().then((answer) => {
          const { gitBranchs } = answer;
          run(gitBranchs, sourceBranch);
        });
      }
    };

    dealwithBranchs(targets, source);
  })
  .parse(process.argv);

