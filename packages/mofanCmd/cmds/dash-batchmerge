#!/usr/bin/env node
const program = require("commander");
const shelljs = require("../utils/shelljsUtil");
const { fork } = require('child_process');
const { askFortargetBranchs } = require("../utils/config");

// const jenkinsUrl = (app, env) =>
//   `http://192.168.0.163:8080/job/tenant-fe/job/${env}/job/${app}/build?token=jenkins-szhtxx-token `;

// 创建一个子进程来执行合并操作
function executeBranch(branch, source_branch) {
  return new Promise((resolve, reject) => {
    const child = fork();
    child.on('message', message => {
      if (message.type === 'error') {
        reject(message.error);
      } else {
        resolve(message.result);
      }
    });
    child.send({ command: `git checkout $branch && git merge $source_branch`, branch, source_branch });
  });
}

program
  .option("-s, --source <source>", "source branch")
  .option("-t, --targets [targets...]", "target branch")
  .action(function ({ source, targets }, args) {
    const run = (branchs, sourceBranch) => {
      Promise.all(
        branchs.map(branch => executeBranch(branch, sourceBranch))
      )
        .then(results => {
          console.log(`Successfully merged $source_branch into ${branchs}`);
          console.log(`Results: ${results}`);
        })
        .catch(error => {
          console.error(`Failed to merge $source_branch into ${branchs}\nError: ${error}`);
        });

      // branchs.forEach((branch) => {
      //   // 生成多个子进程执行以下git操作
      //   // 1、生成多个worktree
      //   // 2、切换到每个worktree
      //   // 3、切换到branch
      //   // 4、merge sourceBranch
      //   // 5、git push
      //   // 6、删除worktree
      //   const res = shelljs.exec(
      //     `git worktree add ${branch} -b ${branch}-merge && cd ${branch} && git checkout ${branch} && git merge ${sourceBranch} && git push && cd.. && git worktree remove ${branch}`
      //   );
      //   console.log("🚀 ~ file: dash-batchmerge:25 ~ branchs.forEach ~ res:", res)
      // });
    };

    const dealwithBranchs = (targetBranchs, sourceBranch) => {
      if (targetBranchs && targetBranchs.length) {
        run(targetBranchs, sourceBranch);
      } else {
        askFortargetBranchs().then((answer) => {
          const { gitBranchs } = answer;
          run(gitBranchs, sourceBranch);
        });
      }
    };

    dealwithBranchs(targets, source);
  })
  .parse(process.argv);

